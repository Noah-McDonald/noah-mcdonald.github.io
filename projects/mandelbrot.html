<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Mandelbrot Viewer</title>

</head>

<body>

<canvas id="myCanvas"></canvas>

<script>
    const canvas = document.getElementById('myCanvas');

    canvas.width = window.innerWidth - 50;
    canvas.height = canvas.width * (5 / 8);

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth - 50;
        canvas.height = canvas.width * (5 / 8);
        sampleSet()
    });
</script>


<div class="controls">
    <button id="zoomIn">Zoom In</button>
    <button id="zoomOut">Zoom Out</button>
    <button id="reset">Reset</button>

    <label for="resolutionSlider">>Resolution</label>
    <input type="range" id="resolutionSlider" min="1" max="1000" value="600">
    <span id="resolutionValue">600</span>

    <label for="depthSlider">Depth</label>
    <input type="range" id="depthSlider" min="1" max="300" value="100">
    <span id="depthValue">100</span>

    <label for="escapeSlider">Escape</label>
    <input type="range" id="escapeSlider" min="1" max="30" value="8">
    <span id="escapeValue">4</span>

    <br><br>
    <label for="formula">Z -> </label>
    <select id="formula">
      <option value="Z^2 + C">Z^2 + C</option>
      <option value="Z^3 + C">Z^3 + C</option>
      <option value="Z^4 + C">Z^4 + C</option>
      <option value="Z^5 + C">Z^5 + C</option>
      <option value="Z^2 + Z + C">Z^2 + Z + C</option>
    </select>

    <p id="result"></p>

  </div>

  <script>
    class Complex {
      constructor(real, imag) {
        this.real = real;
        this.imag = imag;
      }
      mul(that) {
        // (a+bi)(c+di) = ac-bd + i(bc+ad)
        return new Complex(
          this.real * that.real - this.imag * that.imag,  //  real part is ac - bd
          this.real * that.imag + this.imag * that.real   // new imag part is bc+ad
        );
      }
      add(z) {
        return new Complex(this.real + z.real, this.imag + z.imag);
      }
      pow(z) {
        let result = this;
        for (let i = 1; i < z; i++) {
          result = result.mul(this);
        }
        return result;
      }

    }

    function complexToCanvas(z) {
      let x = ((z.real - RE_START) / (RE_END - RE_START)) * canvas.width;
      let y = ((IM_END - z.imag) / (IM_END - IM_START)) * canvas.height;
      return { x, y };
    }

    function canvasToComplex(x, y) {
      let real = RE_START + (x / canvas.width) * (RE_END - RE_START);
      let imag = IM_END - (y / canvas.height) * (IM_END - IM_START);
      return new Complex(real, imag);
    }

    function sampleSet() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const stepX = (RE_END - RE_START) / RESOLUTION;
      const stepY = (IM_END - IM_START) / RESOLUTION;

      const circleRadius = Math.max(1.3, canvas.width / RESOLUTION / 2);

      for (let j = 0; j <= RESOLUTION; j++) {
        const y = IM_START + j * stepY;
        for (let i = 0; i <= RESOLUTION; i++) {
          const x = RE_START + i * stepX;
          let c = new Complex(x, y);

          // escape-time algorithm
          let iter = 0;
          let curr = new Complex(0, 0);
          for (; iter < DEPTH; iter++) {
            if (curr.real ** 2 + curr.imag ** 2 > ESCAPE) break;
            switch (mode) {
              case "Z^2 + C":
                curr = curr.pow(2).add(c);
                break;

              case "Z^3 + C":
                curr = curr.pow(3).add(c);
                break;
              case "Z^4 + C":
                curr = curr.pow(4).add(c);
                break;
              case "Z^5 + C":
                curr = curr.pow(5).add(c);
                break;

              case "Z^2 + Z + C":
                curr = curr.pow(2).add(curr).add(c);
                break;

              case "custom":
                curr = curr.pow(2).add(curr).add(c);
                break;
            }

          }

          // Mandelbrot colouring
          if (iter === DEPTH) {
            ctx.fillStyle = "black";
          } else {
            const band = iter % 16;
            const hue = Math.floor((band / 16) * 360);
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
          }

          let canvas_z = complexToCanvas(c);
          ctx.beginPath();
          ctx.arc(canvas_z.x, canvas_z.y, circleRadius, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }
    // MODE SELECT
    const select = document.getElementById("formula");

    mode = "Z^2 + C" // default mode

    select.addEventListener("change", function () {
      mode = this.value;
      sampleSet();
    });
    // CONFIG

    let RE_START = -2;  	// min real
    let RE_END = 1;   	  // max real
    let IM_START = -1;  	// min imaginary
    let IM_END = 1;   	  // max imaginary

    let RESOLUTION = 600;
    let DEPTH = 100;
    let ESCAPE = 6
    // Z -> Z^2 + C happens DEPTH times


    const ctx = canvas.getContext("2d");



    sampleSet();



  </script>
  <script>
    // UI controls

    const depthSlider = document.getElementById("depthSlider");
    const depthValue = document.getElementById("depthValue");

    const resolutionSlider = document.getElementById("resolutionSlider");
    const resolutionValue = document.getElementById("resolutionValue");

    const escapeSlider = document.getElementById("escapeSlider");
    const escapeValue = document.getElementById("escapeValue");

    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");
    const resetBtn = document.getElementById("reset");

    // Escape circle
    escapeSlider.addEventListener("input", () => {
      ESCAPE = parseInt(escapeSlider.value) / 2;
      escapeValue.textContent = ESCAPE;
      sampleSet();
    });

    // Update resolution
    resolutionSlider.addEventListener("input", () => {
      RESOLUTION = parseInt(resolutionSlider.value);
      resolutionValue.textContent = RESOLUTION;
      sampleSet();
    });

    // Update depth
    depthSlider.addEventListener("input", () => {
      DEPTH = parseInt(depthSlider.value);
      depthValue.textContent = DEPTH;
      sampleSet();
    });

    // Zoom helpers
    function zoomAtCenter(factor) {
      const centerReal = (RE_START + RE_END) / 2;
      const centerImag = (IM_START + IM_END) / 2;

      const width = (RE_END - RE_START) * factor;
      const height = (IM_END - IM_START) * factor;

      RE_START = centerReal - width / 2;
      RE_END = centerReal + width / 2;
      IM_START = centerImag - height / 2;
      IM_END = centerImag + height / 2;

      sampleSet();
    }

    // Buttons
    zoomInBtn.onclick = () => zoomAtCenter(0.5);
    zoomOutBtn.onclick = () => zoomAtCenter(2);
    resetBtn.onclick = () => {
      RE_START = -2;
      RE_END = 1;
      IM_START = -1;
      IM_END = 1;
      sampleSet();
    };

    // Mouse wheel zoom
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY < 0 ? 0.75 : 1.25;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const center = canvasToComplex(x, y);

      //const zoomFactor = 0.5;
      const width = (RE_END - RE_START) * zoomFactor;
      const height = (IM_END - IM_START) * zoomFactor;

      RE_START = center.real - width / 2;
      RE_END = center.real + width / 2;
      IM_START = center.imag - height / 2;
      IM_END = center.imag + height / 2;

      sampleSet();
    });
    // ZOOM LOGIC

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const center = canvasToComplex(x, y);

      const zoomFactor = 0.5;
      const width = (RE_END - RE_START) * zoomFactor;
      const height = (IM_END - IM_START) * zoomFactor;

      RE_START = center.real - width / 2;
      RE_END = center.real + width / 2;
      IM_START = center.imag - height / 2;
      IM_END = center.imag + height / 2;

      sampleSet();
    });
  </script>

</body>

</html>